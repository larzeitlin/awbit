<!DOCTYPE html>
<html>
<head>
  <title>Logo Preview</title>
  <style>
    .spin {
      animation: spin360 1s cubic-bezier(0.45, 0, 0.55, 1);
    }
    @keyframes spin360 {
      from { transform: rotate(0deg);}
      to { transform: rotate(360deg);}
    }
  </style>
</head>
<body>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
      font-family: Tahoma, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
    }
    .bg-half {
      position: fixed;
      inset: 0;
      z-index: -1;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
    }
    .bg-half-top {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 50vh;
      background: black;
      transition: height 1s cubic-bezier(0.45, 0, 0.55, 1);
    }
    .logo-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: transform 1s cubic-bezier(0.45, 0, 0.55, 1);
      will-change: transform;
      z-index: 2;
      position: fixed;
      left: 0;
      right: 0;
      margin-left: auto;
      margin-right: auto;
    }
    .logo-top {
      transform: translateY(calc(-50vh + 70px));
    }
    .bg-half-top.shrink {
      height: 70px;
    }
    .bg-half-bottom {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100vw;
      height: 50vh;
      background: white;
    }
    #pageBody {
      position: fixed;
      left: 0;
      bottom: 0;
      width: 100vw;
      height: calc(100vh - 140px);
      background: #000000;
      z-index: 1;
      box-shadow: 0 -2px 16px rgba(0,0,0,0.04);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      pointer-events: auto;
      transform: translateY(100%);
      transition: transform 1s cubic-bezier(0.45,0,0.55,1);
      font-family: Tahoma, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
    }
  </style>
  <div class="bg-half">
    <div class="bg-half-top" id="bgHalfTop"></div>
    <div class="bg-half-bottom"></div>
  </div>
  <div class="logo-container" id="logoContainer" style="z-index:2; position:fixed; left:0; right:0; margin-left:auto; margin-right:auto;">
    <!-- Add your logo image here -->
    <svg id="logo-svg" width="140" height="140">
      <!-- Outer circle without white outline -->
      <circle cx="70" cy="70" r="50" fill="none" stroke="black" stroke-width="4"/>
      <!-- Center circle with white outline -->
      <circle cx="70" cy="70" r="22" fill="none" stroke="white" stroke-width="6"/>
      <circle cx="70" cy="70" r="20" fill="black"/>
      <!-- Indicator line to north point with white outline -->
      <line x1="70" y1="70" x2="70" y2="20" stroke="white" stroke-width="7"/>
      <line x1="70" y1="70" x2="70" y2="20" stroke="black" stroke-width="3"/>
      <!-- Indicator attachment circle (white outline, black fill) -->
      <circle cx="70" cy="70" r="6" fill="black" stroke="white" stroke-width="2"/>
      <!-- Cardinal point circles -->
      <circle cx="70" cy="20" r="14" fill="white" stroke="black" stroke-width="2"/>
      <circle cx="120" cy="70" r="14" fill="white" stroke="black" stroke-width="2"/>
      <circle cx="70" cy="120" r="14" fill="white" stroke="black" stroke-width="2"/>
      <circle cx="20" cy="70" r="14" fill="white" stroke="black" stroke-width="2"/>

    </svg>
  </div>
  <div id="pageBody" style="
    position: fixed;
    left: 0;
    bottom: 0;
    width: 100vw;
    height: calc(100vh - 140px);
    background: #000000;
    z-index: 1;
    box-shadow: 0 -2px 16px rgba(0,0,0,0.04);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    pointer-events: auto;
    transform: translateY(100%);
    transition: transform 1s cubic-bezier(0.45,0,0.55,1);
    font-family: Tahoma, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
  ">
    <canvas id="three-canvas" style="width:100vw; height:100%; display:block; background:#000;"></canvas>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
  <script>
    const svg = document.getElementById('logo-svg');
    svg.addEventListener('mouseenter', () => {
      svg.classList.add('spin');
    });
    svg.addEventListener('animationend', () => {
      svg.classList.remove('spin');
    });

    // Glide to top on click
    const logoContainer = document.getElementById('logoContainer');
    const bgHalfTop = document.getElementById('bgHalfTop');
    const pageBody = document.getElementById('pageBody');
    let atTop = false;
    svg.addEventListener('click', () => {
      if (!atTop) {
        logoContainer.classList.add('logo-top');
        bgHalfTop.classList.add('shrink');
        pageBody.style.transform = 'translateY(0)';
        // Only start Three.js after transition ends
        pageBody.addEventListener('transitionend', function handler(e) {
          if (e.propertyName === 'transform') {
            initThree();
            pageBody.removeEventListener('transitionend', handler);
          }
        });
        atTop = true;
      }
    });

    // --- Three.js setup ---
    let renderer, scene, camera, line, animationId;

    function resizeThreeCanvas() {
      const canvas = document.getElementById('three-canvas');
      if (!canvas) return;
      const width = window.innerWidth;
      const height = Math.max(0, window.innerHeight - 140);
      renderer && renderer.setSize(width, height, false);
      camera && (camera.aspect = width / height, camera.updateProjectionMatrix());
    }

    function initThree() {
      // Clean up previous renderer if any
      if (renderer) {
        renderer.dispose();
        renderer.forceContextLoss && renderer.forceContextLoss();
        renderer.domElement.parentNode && renderer.domElement.parentNode.removeChild(renderer.domElement);
        cancelAnimationFrame(animationId);
      }

      const canvas = document.getElementById('three-canvas');
      const width = window.innerWidth;
      const height = Math.max(0, window.innerHeight - 140);

      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      //renderer.setClearColor(0x000000, 1);
      renderer.setSize(width, height, false);

      scene = new THREE.Scene();
      camera = new THREE.OrthographicCamera(-width/2, width/2, height/2, -height/2, 1, 10);
      camera.position.z = 5;

      // Spheres at ends of the "line"
      let baseLineLength = width * 0.2;
      let currentLineLength = baseLineLength;
      const sphereRadius = 14;
      const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 32, 32);
      const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const sphereLeft = new THREE.Mesh(sphereGeometry, sphereMaterial);
      const sphereRight = new THREE.Mesh(sphereGeometry, sphereMaterial);
      scene.add(sphereLeft);
      scene.add(sphereRight);

      // --- Sphere mesh trails ---
      const TRAIL_LENGTH = 120;
      function createTrailMesh(color) {
        const material = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.5 });
        const spheres = [];
        for (let i = 0; i < TRAIL_LENGTH; i++) {
          const mesh = new THREE.Mesh(sphereGeometry, material.clone());
          mesh.visible = false;
          mesh.userData.scale = 1; // Track scale for each particle
          scene.add(mesh);
          spheres.push(mesh);
        }
        return spheres;
      }
      const leftTrailSpheres = createTrailMesh(0x00bfff);
      const rightTrailSpheres = createTrailMesh(0xff6a00);

      // Mouse tracking for vertical position
      let mouseY = 0.5;
      let targetMouseY = 0.5;
      canvas.onmousemove = function(e) {
        const rect = canvas.getBoundingClientRect();
        targetMouseY = (e.clientY - rect.top) / rect.height;
      };

      // Animation loop
      let angle = 0;
      // Store trail positions for each sphere
      const leftTrailPositions = Array.from({length: TRAIL_LENGTH}, () => ({x:0, y:0, z:0}));
      const rightTrailPositions = Array.from({length: TRAIL_LENGTH}, () => ({x:0, y:0, z:0}));
      function animate() {
        // Oscillate dot distance from 200% to 50% of base length
        const osc = 0.75 + 0.75 * Math.sin(angle * 0.7);
        currentLineLength = baseLineLength * (0.5 + osc);

        // Update sphere positions (no z-plane orbit)
        const leftPos = -currentLineLength / 2;
        const rightPos = currentLineLength / 2;
        mouseY += (targetMouseY - mouseY) * 0.12;
        const y = (0.5 - mouseY) * height;

        // Main rotation in XY plane only
        const cosA = Math.cos(angle), sinA = Math.sin(angle);

        // Compute new positions
        const leftX = leftPos * cosA;
        const leftY = leftPos * sinA + y * cosA;
        const rightX = rightPos * cosA;
        const rightY = rightPos * sinA + y * cosA;

        sphereLeft.position.x = leftX;
        sphereLeft.position.y = leftY;
        sphereLeft.position.z = 0;

        sphereRight.position.x = rightX;
        sphereRight.position.y = rightY;
        sphereRight.position.z = 0;

        // --- Update mesh trails ---
        function updateTrailMesh(trailPositions, trailSpheres, x, y) {
          // Shift positions and scales back
          for (let i = TRAIL_LENGTH - 1; i > 0; i--) {
            trailPositions[i].x = trailPositions[i-1].x;
            trailPositions[i].y = trailPositions[i-1].y;
            trailPositions[i].z = trailPositions[i-1].z;
            trailSpheres[i].userData.scale = trailSpheres[i-1].userData.scale * 1.05; // Increase radius by 5%
          }
          // Set new head position and reset scale
          trailPositions[0].x = x;
          trailPositions[0].y = y;
          trailPositions[0].z = 0;
          trailSpheres[0].userData.scale = 1;

          // Update mesh positions, scale, and fade
          for (let i = 0; i < TRAIL_LENGTH; i++) {
            const mesh = trailSpheres[i];
            const pos = trailPositions[i];
            if (i === 0 || pos.x !== 0 || pos.y !== 0) {
              mesh.visible = true;
              mesh.position.set(pos.x, pos.y, pos.z);
              mesh.scale.setScalar(mesh.userData.scale);
              mesh.material.opacity = 0.5 * (1 - i / TRAIL_LENGTH);
            } else {
              mesh.visible = false;
            }
          }
        }
        updateTrailMesh(leftTrailPositions, leftTrailSpheres, leftX, leftY);
        updateTrailMesh(rightTrailPositions, rightTrailSpheres, rightX, rightY);

        angle += 0.015;
        renderer.render(scene, camera);
        animationId = requestAnimationFrame(animate);
      }

      animate();
      window.addEventListener('resize', () => {
        resizeThreeCanvas();
        // Update camera and base line length on resize
        const width = window.innerWidth;
        const height = Math.max(0, window.innerHeight - 140);
        camera.left = -width/2;
        camera.right = width/2;
        camera.top = height/2;
        camera.bottom = -height/2;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        baseLineLength = width * 0.2;
      });
    }
  </script>

</body>
</html>